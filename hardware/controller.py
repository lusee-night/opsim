from hardware.panels import *
# ---
class Controller:
    profile = None# If set, represents the time series for the power generated by the panels

    # ---
    def __init__(self, env=None, sun = None, verbose = False):
        self.env        = env
        self.sun        = sun
        self.verbose    = verbose

    
        self.panels     = []
        self.devices    = {}
        self.power      = None # this is calculated later

    ### PANELS SECTION ###
    def add_panel(self, panel):
        panel.set_condition(self.sun.condition)
        self.panels.append(panel)

    ### DEVICES SECTION ###
    def add_device(self, device):
        self.devices[device.name]=device

    def set_device_state(self, name, state):
        self.devices[name].state = state

    ###
    def add_all_panels(self):
        self.add_panel(EPanel(self.sun, 'E'))
        self.add_panel(WPanel(self.sun, 'W'))
        self.add_panel(TPanel(self.sun, 'T'))

    ###
    def add_panels_from_config(self, config):
        pcf     = config['config'] # panel config
        panels  = config['panels'] # list of panels
    
        lander_roll     = float (pcf['lander_roll'])
        lander_pitch    = float (pcf['lander_pitch'])
        lander_yaw      = float (pcf['lander_yaw'])

        if (lander_roll != 0.0) or (lander_pitch != 0.0) or (lander_yaw != 0.0):
            print ('Lander roll/pitch/yaw: ', lander_roll, lander_pitch, lander_yaw)

        pvEFF_T = np.array([float(x) for x in pcf['PV_efficiency']['temp'].split()])
        pvEFF_P = np.array([float(x) for x in pcf['PV_efficiency']['power'].split()])

        for panel in panels:
            normal = np.array([float(x) for x in panel['normal'].split()])
            eff = panel['efficiency']
            if self.verbose: print(f'''Adding panel {panel['name']} with normal {normal}, efficiency {eff} and surface area {panel['area']}''')
            self.add_panel(Panel(self.sun, panel['name'], normal, self.env, eff, pvEFF_T, pvEFF_P))


        # for panel_name, panel in config.items():
        #     if panel_name=='config':
        #         continue
        #     normal = np.array([float(x) for x in panel['normal'].split()])
        #     eff = panel['efficiency']
        #     print(f'''Adding panel {panel_name} with normal {normal} and efficiency {eff}''')
        #     self.add_panel(Panel(self.sun, panel_name, normal, self.env, eff, pvEFF_T, pvEFF_P))
                        
    
    
    ###
    def get_panel(self, name):
        for p in self.panels:
            if p.name==name: return p
        return None
    ###
    def panels_info(self):
        info = f'''Number of panels: {len(self.panels)}\n'''
        for p in self.panels:
            info += f'''Panel info: {p.info()}\n'''
        print(info)

    
    ###
    # An aggregator, to collect power from the panels
    def calculate_power(self):
        power = None
        for p in self.panels:
    
            if power is None:
                power = p.power()
            else:
                power = power + p.power()

        self.power = power

    ### Static method to read the panel exposure profile
    @staticmethod
    def read_profile(filename):
        try:
            with open(filename, 'rb') as f: Controller.profile = np.load(f)
            if Controller.verbose: print(f'''Loaded data from file "{filename}", number of points: {Controller.profile.size}''')
        except:
            if Controller.verbose: print(f'''ERROR using file {filename} as the data source for the power profile''')
